{
  // ============================================================
  // Fenêtre temporelle d’évaluation
  // ============================================================
  "window": {
    "start_hhmm": "06:00", // début de la fenêtre d’évaluation (inclus), format HH:MM
    "end_hhmm": "09:00"    // fin de la fenêtre d’évaluation (exclu), format HH:MM
  },

  // Nom du cas (sert d’identifiant)
  "case_name": "Example_Route_Multistop",

  // Module externe optionnel contenant des tie-breakers personnalisés
  "tie_breakers": {
    "module": "tie_breakers" // doit exposer TIE_BREAKERS = { "nom": fonction, ... }
  },

  // ============================================================
  // Modes / services de transport
  // ============================================================
  "modes": [
    {
      // ----------------------------------------------------------
      // Service fixe (non optimisé) basé sur pattern_streams
      // ----------------------------------------------------------
      "name": "Trains Hub",
      "category": "rail",
      "pattern_streams": [
        {
          "label": "IC→X",            // label informatif
          "depart_minutes": [11, 44], // minutes dans l’heure répétées sur la fenêtre (+padding)
          "arr_offset_min": 0,        // arrivée = départ + 0 min
          "w": 1.0                    // poids du flux
        }
      ]
    },

    {
      // ----------------------------------------------------------
      // Service à optimiser : topology="route" (boucle multi-stops)
      //
      // Interprétation dans le code (transit_core.expand_route_anchors) :
      // - stops = [S0, S1, ..., S{N-1}] avec S0 = stop de référence
      // - leg_minutes a longueur N et contient les temps :
      //     S0->S1, S1->S2, ..., S{N-2}->S{N-1}, S{N-1}->S0   (DERNIÈRE jambe incluse)
      // - pattern_minutes s’applique aux DÉPARTS de S0 (S0=HubStop ici)
      // - pour i>=1 :
      //     arr[Si] = dep[S0] + offset_arr[i]
      //     dep[Si] = arr[Si] + dwell(Si)
      // - pour S0 :
      //     dep[S0] = pattern (pas de dwell appliqué sur les départs de S0)
      //     arr[S0] = dep[S0] + durée_cumulée_jusqu’au_retour (fermeture de boucle)
      // ----------------------------------------------------------
      "name": "Bus Route",
      "category": "bus",
      "template": {
        "topology": "route",

        "stops": ["HubStop", "Stop2", "Stop3", "Stop4"], // ordre des arrêts, S0 = "HubStop"
        "leg_minutes": [7, 6, 8, 5], // temps (min) : HubStop->Stop2, Stop2->Stop3, Stop3->Stop4, Stop4->HubStop
        "dwells": {
          "Stop3": 3 // arrêt/temps de stationnement (minutes) ajouté AVANT de repartir de Stop3
        },

        "n_per_hour": 3,          // nombre de départs/h au stop de référence S0 (=HubStop)
        "equal_headway": false    // false => patterns combinatoires (sous contrainte de gap minimal)
      }
    }
  ],

  // ============================================================
  // Transferts (correspondances)
  // ============================================================
  "transfers": [
    {
      // Correspondance : Train -> Bus (à HubStop)
      "from_service": "Trains Hub",
      "from_anchor": "default",

      "to_service": "Bus Route",
      "to_anchor": "HubStop", // IMPORTANT : doit être exactement un des stops de la route

      "walk_time": 2,         // temps de marche (minutes)
      "min_margin": 1,        // marge minimale (minutes)

      "w_up": 1.0,            // sens "montée" (arrivée train -> départ bus)
      "w_down": 0.0,          // sens retour ignoré ici

      "tie_breaker": "min_variance", // minimise la dispersion (proxy via std_up/std_down) sur les ex æquo
      "tie_params": {}               // pas de paramètres pour min_variance
    }
  ],

  // ============================================================
  // Services à optimiser (ordre séquentiel)
  // ============================================================
  "targets": ["Bus Route"]
  // Ici : on optimise uniquement la route bus (le train est fixe et sert de référence)
}
